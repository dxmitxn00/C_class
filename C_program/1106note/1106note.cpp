//-malloc : 비는 메모리를 원하는 만큼 선정해서 돌아다니는 메모리 사용
//= > sizeof() 함수 : 배열의 크기를 구하는 함수
//ㄴ > malloc이 없으면 sizeof함수 사용못함
//======> malloc의 개수를 선언해주면 못바꿈,
//선언은 동적으로 자유지만 선언하면 정적이 되어버림 == 단점
//
//- realloc : malloc의 단점 보완 - 선언 후에 메모리를 더 추가할 수 있음
//
//% d(% i) 정수
//% f      실수
//% lf      실수(큰 애)
//% c      문자
//% s      문자열
//% x      16진법(메모리 주소는 16진법, 그냥 정수형은 8진법)
//% o      8진법
//
//
//---- > 포인터를 사용하는 이유 : 주소를 통해서 쉽게 데이터를 접근하기 편하기 위해서
//
//
//배열 선언->방을 만들어놔줌 : 그 안에서 메모리 활용
//배열 선언x->malloc(sizeof())활용 : 배열없이 필요한 메모리 영역을 확보해줌(동적메모리)
//ㄴ > 앞에 데이터형 써줘야함    ㄴ > 메모리 확보를 위해 사이즈크기 알아야함
//>>>>malloc 헤더 파일 하나 더 필요함 // #include<malloc.h>
//
//
//
//int main(void) {
//	int* p;
//	int i, sum = 0;
//	int cnt;
//
//	printf("입력 개수를 적어주세요 : ");
//	scanf("%d", &cnt);
//
//	p = (int*)malloc(sizeof(int) * cnt);
//
//	for (i = 0; i < cnt; i++) {
//		printf("%d번째 숫자 : ", i + 1);
//		scanf("%d", p + i);
//	}
//	for (i = 0; i < cnt; i++) {
//		sum += *(p + i);
//		printf("입력한 숫자의 합은 : %d \n", sum);
//	}
//	free(p);
//	return 0;
//}
//
//
//ㄴ > free() : malloc사용했으면 메모리를 해제해주어야 함(안해줘도 되는데 그럼 느려짐)
//delete()
//
//- 배열의 길이값 = sizeof(배열이름) / sizeof(데이터형)
//
//--------------------------------------------------------------------------------------------
//
//// 컴퓨터는 32bit(포인터 변수 = 4byte) 64bit(포인터 변수 = 8byte)밖에 없다.
//메모리주소는 정수다.
//- 포인터 / 함수 포인터 / 배열 포인터 / 포인터 연산
//
//- 포인터 변수 선언 = > 포인터도 변수이다.주소를 담는 것 뿐 // 포인터변수도 초기화 가능
//
//// 포인터 변수의 초기화 (int a = 0;과 같음)
//ptr 포인터 변수는 NULL로 초기화 : 데이터의 주소값을 가지고 있지 않다.
//(본인의 메모리 주소는 있음)
//
//int* ptr = NULL; //4byte인 ptr포인터변수에 4byte짜리 정수 데이터값을 받음
//char* ptr = NULL; //4byte인 ptr포인터변수에 1byte짜리 문자 데이터값을 받음
//float* ptr = NULL; //4byte인 ptr포인터변수에 4byte짜리 실수 데이터값을 받음
//= > 포인터 변수 자체는 4byte라서 세 변수는 총 12byte를 가짐
//
//!!!!!!!!!!!!!!!!!!!!!!!포인터 변수에 주소를 저장하지 않으면 값을 넣을 수 없다. !!!!!!!!!!!!!!!!!!!!!!!!!!!
//포인터 변수는 사용자가 직접 메모리 주소를 지정해서 초기화할 수 없다.
//(초기화는 NULL만 가능)
//
//--------------------------------------------------------------------------------------------
//
//배열에서는 주소연산자 붙을 수 없음 = > 배열자체에 주소의 의미를 내포하기 때문에
//* &ch[i](X)   ch[i](O)
//
//--------------------------------------------------------------------------------------------
//
//- 함수 포인터(4byte) : 함수가 저장되어 있는 메모리의 주소를 받고 있는 것
//
//int (*test)(int, int)
//ㄴ > 함수 포인터 이름을 설정할 때에는 반드시 괄호와 * 를 사용한다.
//
//ex)	int (*pt)(int num, int num2)
//== int (*pt)(int, int)    // int에 들어가 변수를 밑에 꼭 선언해줘야함
//
//
//
//-함수포인터의 하드웨어 저장소
//stack : 변수 저장
//heap : 변수의 값 저장
//..... : 함수 저장         // 전처리 <stdio.h>에 입출력 함수 포함(이미 메모리주소 확보)
//
//
//
//
//void add(float num1, float num2); // 가리키는 대상의 함수
//
//int main(void) {
//	float x = 4.1, y = 6.1;
//	void (*pointer)(float, float); // 함수 포인터 선언
//
//	printf("add함수 주소 : %x \n", add);
//	printf("함수 포인터 주소는 : %x \n", &pointer);
//
//	pointer = add; // 함수 포인터에 함수 시작 주소를 저장
//	pointer(x, y); // 함수 포인터를 이용하여 함수를 호출
//
//	return 0;
//}
//
//void add(float num1, float num2) {
//	float result;
//	result = num1 + num2;
//	printf("%f + %f = %f \n", num1, num2, result);
//}
//
//
//
//
//============================퀴즈========================== =
//
//[문제] int형 변수 num1, num2를 선언과 동시에 10과 20으로 초기화 한다.
//int형 포인터 변수 ptr1, ptr2를 선언한다.
//그리고 각각 num1, num2를 가리키게 한다.
//그 상태에서 포인터 변수 ptr1, ptr2를 이용하여
//num1, num2의 값을 각각 20 증가, 10 감소를 시킨다.
//그리고 나서 ptr1, ptr2가 가리키는 대상을 서로 바꾼다.
//ptr1 = num2, ptr2 = num1
//그리고 나서 각각 출력한다.
