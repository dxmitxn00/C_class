//함수(4종류) / 변수 종류(전역변수, 지역변수, 정적변수static(= 초기화 // 전역변수의 단점을 보완한 것)) / 재귀함수 / 포인터 / 배열 / 구조체(동적메모리) / (문자열은 키워드가 없음, 배열 안에 포함)
//
//	- static 같이 설명하는 키워드가 const(상수)
//
//	int test = 1 //  변수
//	int TEST = 1 // 상수(대문자로 쓰면 상수)
//	static int test = 1 // 변수지만 상수처럼 쓰임, 한번만
//
//
//	1. int a(int b)
//	2. int a(void)
//	3. void a(int a)
//	4. void a(void)
//	= > 사용자 정의 함수가 대부분
//
//	- 함수 1. 사용자 정의 함수
//	2. main() 함수              ==== = > c언어는 함수의 집합체
//
//	- return 0; 의 의미 : 함수가 정상적으로 종료됐다는 의미
//	함수가 끝나서 빠져나오겠다는 의미
//	0의 의미는 결과값을 돌려주는 것(int면 return 뒤에 정수가 나와야함)
//	ㄴ return result; 는 result의 결과값을 돌려준다는 의미(주로 사용자 정의 함수에서 쓰임)
//	void main() 으로 함수 실행하면 함수없이 다이렉트로 출력한다는 것.
//	int 타입을 설정해 주면 main함수에 결과값을 돌려줘서 확인하는 것.
//	= > return 안하면 충돌일어날 수 있음 -> int main(void)으로 고정시킴(안시에서)
//
//	- int(반환 형태, 출력 형태) function name(매개 변수, 입력 형태)
//
//	int a(int b, char c) {        // a함수의 b는 정수, c는 문자의 입력 형태를 받는 구나
//	실행 구문(함수의 기능);
//	return 구문;                  // 함수 실행이 정상적으로 완료(에러생기면 실행 안
//}
//
//------------------------------------------------------------------ -
//
//int sum(int x, int y) {
//	int result = 0;           // 변수 선언(정수형)
//	result = x + y;
//	return result;
//}
//
//int main(void) {
//	int answer = 0;
//	answer = sum(5, 5);
//	printf("%d \n", answer);
//	return 0;
//}
//
//--------------------------------------------------------------------
//
//int main(void) {
//	printf("Test");
//	return result;
//}
//
//int test(void) {
//	int num = 0;
//	scanf("%d", &num);
//	printf("num");
//	return 0;
//}
//
//-------------------------------------------------------------------- -
//
//
//비교하거나 조건을 충족시키는 것은 사용자 정의 함수가 좋음
//->입출력만 main 함수에서 해줘야 효율적
//
//- 변수 1. 지역 변수, 함수가 실행하면 살아나고 함수가 종료하면 죽는다.
//(함수 안에 존재)      선언과 동시에 초기화 해줘야함.
//2. 전역 변수, 프로그램이 종료하면 죽는다.
//선언하면 자동 초기화 됨
//
//- " ", NULL : 같은 널이지만 의미가 다름
//ㄴ "" : 지금은 값이 없지만 언젠가는 들어옴, 공백이 생김
//ㄴ NULL : 상수의 형태(완벽한 상수는 아님), 값을 받지 못함
//== = > 상수는 변수와 달리 수가 변하지 않음
//
//
//int a(int b) {
//
//	int f;
//}
//
//int h(int b) {
//
//	int f;
//}
//ㄴ > 각 함수 안에 int f; (전역변수)는 이름은 같지만 전혀 다른 애들
//
//
//
//int sub(int x, int y) {
//	int sub(int x, int y) {
//		return x + y;                        result = x + y;
//	}                                           return result;
//	ㄴ > 두개 같음
//}
//
//
//
//-전역변수가 많으면 지역변수가 뭔지 헷갈림, 웬만하면 지역을 많이 쓰고 전역은 피해라
//
//--------------------------------------------------------------------------------------------
//
//- 포인터 : 컴퓨터의 메모리 주소를 지칭 = 접근성이 뛰어나다
//* &->두가지만 알면 됨
//* : 포인터 변수 선언하는 연산자
//& : 주소 연산자
//
//char c; // 문자만 받을 수 있음, 주소는 받을 수 없음
//int a;  // 정수만 받을 수 있음, 주소는 받을 수 없음
//int* pc // pointer의 p를 앞에 따고 포인터 변수이름 붙임
//ㄴint* pc = int* pc = int* pc
//
//int a; // 정수형 변수 a 선언
//int* p; // 포인터 변수 p 선언  ---> 같은 변수인데 메모리 주소를 받는 변수
//p = &a; // 위에서 포인터 변수 선언을 했기 때문에 또 *을 쓸 필요가 없음
//a가 있는 메모리 주소 값을 가져옴
//ㄴ 그 주소안의 데이터를 간접 접근으로 가져옴
//(데이터 저장은 X, 주소만 저장)
//
//
//printf("ch가 가지고 있는 값은 : %c \n", ch);
//// ch 데이터를 가져오고자 함
//printf("ch의 메모리 주소 값은 : %d \n", &ch);
//// 메모리 주소는 정수니까 %d 로 해줘야함
//printf("p가 가지고 있는 값은 : %d \n", p);
//// p변수에는 메모리 주소만 저장됨 -> 메모리 주소를 가져오고자 함 
//printf("p가 가리키는 곳의 실제 값은 : %c \n", *p);
//// 포인터 p가 가리키는 주소의 데어터 값(ch의 데이터)을 가져오고자 함
//
//----->지역변수는 함수 실행하면 메모리 영역 중에 stack에 저장되었다가 끝나면 사라짐
//
//
//int main(void) {
//	char ch;
//	char* p;
//	char* q;
//
//	ch = 'A';
//	p = &ch; //p는 ch의 주소를 가짐
//
//	q = p; //q는 p가 가진 ch의 주소를 가짐
//
//	*q = 'Z'; //*q는 p를 통해서 ch의 위치에 가서 A라는 데이터를 Z로 바꿈
//
//	printf("ch에 저장되어 있는 값은 : %c \n", ch);
//
//	return 0;
//}
//
//
//
//
//void swap(int a, int b) {
//	int temp = a;
//	a = b;
//	b = temp;
//}
//
//int main(void) {
//	int first = 20, second = 30;
//	printf("before : frist = %d, second = %d \n", first, second);
//
//	swap(first, second);
//	printf("after : frist = %d, second = %d \n", first, second);
//}
//
//? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
//
//void swap(int* a, int* b) {
//	int temp = *a;
//	*a = *b;
//	*b = temp;
//}
//
//int main(void) {
//	int first = 20, second = 30;
//	printf("before : frist = %d, second = %d \n", first, second);
//
//	swap(&first, &second);
//	printf("after : frist = %d, second = %d \n", first, second);
//}
